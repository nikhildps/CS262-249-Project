sMAP is a specification for a protocol which exposes and publishes time-series data from a variety of sensors. The main components of sMAP include sources (a restful web service that accepts requests and publishes sensor data), archivers (persistent storage of sensor data in the form of a time-series), and applications (perform visualization and analysis of sensor data to create actuation signals). We introduced modularity in the sMAP architecture by isolating sMAP sources from the initial implementation of all sMAP components on FitPC, and moving them to embedded drivers. The sMAP source,which accepts requests for sensor data as HTTP PUT requests, and sends sensor data as JSON over HTTP to the URI specified in the request, was deployed on a lightweight microcontroller. A combination of the source and sensor is referred to as a sMAP source node. A group of  such source nodes are controlled isochronously though a zone controller. 

The sMAP sources are responsible for collecting data natively from sensor appliances. This data is relayed in the form of JSON packets over HTTP to the requestor service. In sMAP’s original architecture, the requestor can be a web service that requires sensor data to be published over the internet, or it can be sMAP’s customized data archiver. Each source is associated with a unique 128-bit identifier. The sMAP source is capable of interacting over a network using HTTP. Since the GDP requires specific data and formatting that is incompatible with what sMAP currently issues, we built an HTTP server interface atop DLog which accepts HTTP PUT requests from any source that issues sensor data in the form of HTTP/JSON and converts them into a GDP-friendly format. Since both the zone-controller and the sMAP sources issue data, the HTTP interface has been built generically to handle several types of sources. 

The original implementation of sMAP is through Python and a set of Python dependencies on FitPC. Isolating sources enables ease of installation and flexibility. Deploying sources on embedded drivers achieves energy efficiency and reduces cost. Since most embedded devices speak C, the ideal approach is to create a C implementation of the sMAP source, and deploy this on an embedded platform such as Arduino which can natively interact with a sensor. However, sMAP sources are required to act as both a server and a client. This posed a problem as Arduino provides only a single thread of execution. We attempted to use timer interrupts to implement a multi-threaded model but due to the limitations of embedded platforms and complexity of the code, this implementation was unstable. Round-robin scheduling of client and server activities served as a work-around. Currently, our hardware setup allows the Arduino sMAP source to accept requests for sensor data as HTTP POST Requests, establishes interaction between a temperature sensor and the Arduino, and sends out sensor data as JSON packets over HTTP to a server. The temperature is also displayed natively on an LCD, to ensure consistency and measure lag as complexity increases.

In order to analyze the stability of control loops, it is imperative to establish a global notion of time and achieve timed control. A zone controller ensures that each node subscribes to a common time, and local time on nodes is regularly corrected. It also performs intelligent analysis on incoming sensor data from a group of sensors corresponding to a physical zone, and generates appropriate actuation signals on actuators pertaining to that zone. The actuation signals are sent out to actuators as soon as they are computed, but the actuation itself takes place in an isochronous manner to improve stability. The notion of time is introduced through Real Time Clock (RTC) shields on Arduino. The zone-controller is capable of sending sensor data to the GDP as HTTP/JSON.

In our use case, we consider a simple temperature-control system within a closed room. We consider two temperature sensors, one within a room (R) and one placed outside to measure the environment’s temperature (E). We also consider two actuators: the HVAC system (HVAC) and the Economizer (ECON). The values of E and R are sent to a zone-controller (Z.C) isochronously. The HTTP response sent by Z.C to E and R contains embedded local time in JSON packets, which are used to update the sensors’ local time. The Z.C analyzes the values from E and R and sends actuation signals to HVAC and ECON. These actuation signals vary depending on the heating and cooling set-points and the current temperature measured by the sensors. The signals are sent out as soon as they are computed, but the actuation is done by HVAC and ECON isochronously. Time synchronization is maintained among the actuators by using piggy-backed time signals embedded in the actuation command issued by the Z.C.